-- CREATE
-- 테이블 생성

CREATE TABLE MEMBER(
	MEMBER_NO NUMBER,
	MEMBER_ID VARCHAR2(20),
	MEMBER_PWS VARCHAR2(20),
	MEMBER_NAME VARCHAR2(15)
);
SELECT * FROM MEMBER;
DROP TABLE MEMBER;


-- 테이블 사전
-- 현재 계정의 테이블 목록
SELECT * FROM USER_TABLE;
-- 컬럼들의 목록
SELECT * FROM USER_TAB_COLUMNS WHERE TABLE_NAME = 'MEMBER';


-- 제약조건
-- NOT NULL
-- '널 값 허용하지 않겠다.'
-- 반드시 값을 기록해야 하는 컬럼에 해당 제약조건을 등록
-- INSERT/UPDATE/DELETE 시에 NULL값을 허용하지 않도록 등록.

CREATE TABLE USER_NOCONS(
	USER_NO NUMBER,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(30),
	USER_NAME VARCHAR(15)
);
SELECT * FROM USER_NOCONS;


-- 테이블에 값 추가하기
-- INSERT => DML
INSERT INTO USER_NOCONS VALUES(1, 'USER01', 'PASS01','이창진');
SELECT * FROM USER_NOCONS;
INSERT INTO USER_NOCONS VALUES(2, NULL, NULL, NULL);

CREATE TABLE USER_NOT_NULL(
	USER_NO NUMBER NOT NULL,
	USER_ID VARCHAR2(20) NOT NULL,
	USER_PWD VARCHAR2(30) NOT NULL,
	USER_NAME VARCHAR2(15)
);
SELECT * FROM USER_NOT_NULL;

INSERT INTO USER_NOT_NULL VALUES(1,'USER01','PASS01','이창진');

-- SQL Error [1400] [23000]: ORA-01400: NULL을 ("MULTI"."USER_NOT_NULL"."USER_ID") 안에 삽입할 수 없습니다
INSERT INTO USER_NOT_NULL VALUES(1,NULL,NULL,NULL);

-- NAME은 NOT NULL 제약조건을 등록하지 않았기에 NULL 값이 잘 들어 간다.
INSERT INTO USER_NOT_NULL VALUES(2,'USER02','PASS02',NULL);



--  UNIQUE --
-- 중복을 허용하지 않는 제약조건
-- 컬럼에 값을 입력/ 수정 할때 중복 확인하여
-- 만약 값이 있을 경우 값을 수정 및 추가를 못하게 하는 제약조건

INSERT INTO USER_NOCONS VALUES(1,'USER01','PASS01','권장현');
SELECT * FROM USER_NOCONS;


CREATE TABLE USER_UNIQUE(
	USER_NO NUMBER,
	USER_ID VARCHAR2(20) UNIQUE, -- 컬럼레벨 제약조건
	USER_PWD VARCHAR2(30),
	USER_NAME VARCHAR2(15)
);
SELECT * FROM USER_UNIQUE;

INSERT INTO USER_UNIQUE
VALUES(1, 'USER01','PASS01','권장현');

SELECT * FROM USER_UNIQUE;

-- ID만 다르게 해서 INSERT를 실행
-- 에러 없이 추가
INSERT INTO USER_UNIQUE
VALUES(1, 'USER02','PASS01','권장현');

SELECT *
FROM USER_CONSTRAINTS C1
JOIN USER_CONS_COLUMNS C2 ON (C1.CONSTRAINT_NAME = C2.CONSTRAINT_NAME)
WHERE C1.TABLE_NAME = 'USER_UNIQUE';

SELECT *
FROM USER_CONSTRAINTS C1
JOIN USER_CONS_COLUMNS C2 ON (C1.CONSTRAINT_NAME = C2.CONSTRAINT_NAME)
WHERE C1.TABLE_NAME = 'USER_NOT_NULL';



-- CONS TYPE
-- P: PRIMARY KEY
-- C: CHECK, NOT NULL
-- U: UNIQUE
-- R: FOREIGN KEY(REFERENCE)

CREATE TABLE USER_UNIQUE2(
	USER_NO NUMBER,
--	USER_ID VARCHAR2(20) UNIQUE, -- 컬럼레벨
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(30),
	USER_NAME VARCHAR2(15),
	UNIQUE(USER_ID) -- 컬럼이 모두 작성 된 후에 별도로 작성하는 제약조건을 테이블 레벨 제약 조건이라 한다.
);
INSERT INTO USER_UNIQUE2 VALUES(1, 'USER01','PASS01','권장현');

-- SQL Error [1] [23000]: ORA-00001: 무결성 제약 조건(MULTI.SYS_C0023225)에 위배됩니다
INSERT INTO USER_UNIQUE2 VALUES(1, 'USER01','PASS01','권장현');

SELECT * FROM USER_UNIQUE2;



-- UNIQUE 제약조건을 여러개 컬럼에 적용하기
-- 두 개 이상의 컬럼을 하나의 제약조건으로 묶자
-- 테이블 레벨에서 선언
-- D1 10
-- D1 20
-- D2 10
-- D2 20
-- D3 10
-- D3 20

CREATE TABLE USER_UNIQUE3(
	USER_NO NUMBER,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(30),
	USER_NAME VARCHAR2(15),
	UNIQUE(USER_NO, USER_ID)
	-- 두 개 이상의 컬럼값을 중복되지 않게 설정하기
); 
SELECT * FROM USER_UNIQUE3;

INSERT INTO USER_UNIQUE3 VALUES(1,'USER01','PASS01','권장현');
INSERT INTO USER_UNIQUE3 VALUES(1,'USER02','PASS02','김장현');

INSERT INTO USER_UNIQUE3 VALUES(2,'USER01','PASS03','박장현');


-- 제약 조건에 이름 설정
CREATE TABLE CONS_NAME(
	TEST_DATA1 NUMBER CONSTRAINT NN_DATA1 NOT NULL,
	TEST_DATA2 VARCHAR2(30) CONSTRAINT UN_DATA1 UNIQUE,
	TEST_DATA3 VARCHAR2(30),
	CONSTRAINT UK_DATA3 UNIQUE(TEST_DATA3)
);

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'CONS_NAME';

SELECT * FROM CONS_NAME;

-- CHECK --
-- 컬럼에 값을 기록할 때 지정한 값 이외에는 값이
-- 저장되지 않도록 범위를 제한하는 조건
CREATE TABLE USER_CHECK(
	USER_NO NUMBER,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(30),
	USER_NAME VARCHAR(15),
	GENDER CHAR(3) CHECK(GENDER IN ('남','여'))
);

SELECT * FROM USER_CHECK;

INSERT INTO USER_CHECK VALUES(1, 'USER01','PASS01','홍길동','여');

-- SQL Error [12899] [72000]: ORA-12899: "MULTI"."USER_CHECK"."GENDER" 열에 대한 값이 너무 큼(실제: 6, 최대값: 3)
INSERT INTO USER_CHECK VALUES(2, 'USER02','PASS02','김길동','여성');

-- SQL Error [2290] [23000]: ORA-02290: 체크 제약조건(MULTI.SYS_C0023233)이 위배되었습니다
INSERT INTO USER_CHECK VALUES(2, 'USER02','PASS02','김길동','F');
INSERT INTO USER_CHECK VALUES(2, 'USER02','PASS02','김길동','김');

-- INSERT 성공
INSERT INTO USER_CHECK VALUES(2, 'USER02','PASS02','김길동','남');

-- CHECK 조약조건에 부등호 처리
CREATE TABLE USER_CHECK2(
	TEST_DATA NUMBER,
	CONSTRAINT CK_TEST_DATA CHECK(TEST_DATA > 0)
);

INSERT INTO USER_CHECK2 VALUES(10);

SELECT * FROM USER_CHECK2;

-- SQL Error [2290] [23000]: ORA-02290: 체크 제약조건(MULTI.CK_TEST_DATA)이 위배되었습니다
INSERT INTO USER_CHECK2 VALUES(-10);

CREATE TABLE USER_CHECK3(
	PRICE NUMBER,
	GRAND CHAR(1),
	CONTRAINT CK_USER_CHECK3_PRICE CHECK(PRICE BETWEEN 1 AND 99999),
	CHECK(GRADE >= 'A' AND GRADE<= 'F');
);

-- 한 컬럼에 제약 조건 여러개를 설정하기
CREATE TABLE TEST_DUAL_CONS(
	TST_NO NUMBER NOT NULL UNIQUE
);
SELECT * FROM USER_CONS_COLUMNS
WHERE TABLE_NAME = 'TEST_DUAL_CONS';

-- PRIMARY KEY 제약조건 --
-- '기본키 제약조건'
-- 테이블 내의 데이터를 중에서 한 행을 식별하기 위한 고유값
-- 테이블 전체에 대한 각 데이터(ROW)의 식별자 역할을 수행시키는 제야조건
-- NOT NULL과 UNIQUE 제약 조건이 부여
-- 값이 반드시 들어가고, 중복이 있어서도 안된다.

-- 테이블 마다 기본키는 하나만 존재.(하나의 컬럼에만 기본키 제약조건을 설정 가능)
-- PRIMARY KEY는 한 컬럼에 적용가능하고, 여러 컬럼을 묶어서도 적용가능

CREATE TABLE USER_PK_TABLE(
	USER_NO NUMBER CONSTRAINT PK_USER_NO PRIMARY KEY,
	USER_ID VARCHAR2(20) UNIQUE NOT NULL,
	USER_PWD VARCHAR2(30) NOT NULL,
	USER_NAME VARCHAR(15) NOT NULL,
	GENDER VARCHAR2(3) CHECK(GENDER IN('남','여'))
);

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'USER_PK_TABLE';

INSERT INTO USER_PK_TABLE
VALUES(1, 'USER01','PASS01','권장현','남');

SELECT * FROM USER_PK_TABLE;

INSERT INTO USER_PK_TABLE
VALUES(2, 'USER02','PASS02','김장현','여');

-- SQL Error [1] [23000]: ORA-00001: 무결성 제약 조건(MULTI.PK_USER_NO)에 위배됩니다
INSERT INTO USER_PK_TABLE
VALUES(1, 'USER03','PASS03','박장현','여');

-- SQL Error [1400] [23000]: ORA-01400: NULL을 ("MULTI"."USER_PK_TABLE"."USER_NO") 안에 삽입할 수 없습니다
INSERT INTO USER_PK_TABLE
VALUES(NULL, 'USER03','PASS03','박장현','여');


SELECT * FROM USER_PK_TABLE;
-- 기본키 제약조건을 설정하면 NOT NULL과 UNIQUE가 함께 설정 된다.


-- 기본키 제약조건을 여러컬럼에 적용하기
CREATE TABLE USER_PK_TABLE2(
	USER_NO NUMBER,
	USER_ID VARCHAR2(20) UNIQUE NOT NULL,
	USER_PWD VARCHAR2(30) NOT NULL,
	USER_NAME VARCHAR(15) NOT NULL,
	GENDER VARCHAR2(3) CHECK(GENDER IN('남','여'))
	CONSTRAINT PK_USER_NO2 PRIMARY KEY(USER_NO, USER_ID)
);

-- 1, USER01 => 성공
-- 2, USER02 => 성공
-- 1, USER01 => 성공
-- 2, USER01 => 실패

-- MEMBER 테이블을 생성
-- 사용자 정보를 받아 저장할 수 있는 테이블 객체를 생성하는데
-- 회원번호는 NUMBER 형태로 기본키 설정,
-- 회원 아이디는 중복 불가에 필수 입력사항,
-- 회원 비밀번호는 필수 입력사항
-- 회원 이름,
-- 성별('F','M')만 입력 받을 수 있게,
-- 회원 연락처
-- 이러한 회원의 정보를 저장할 수 있는 컬럼을 가진 MEMBER 테입블 생성
-- 컬럼의 크기는 편한데로, 테이블 생성 후헤는 INSERT 5번 이상 진행 후 SELECET까지 확인

DROP TABLE MEMBER;
CREATE TABLE MEMBER(
	USER_NO NUMBER CONSTRAINT PK_MEMBER PRIMARY KEY,
	USER_ID VARCHAR2(20) UNIQUE NOT NULL,
	USER_PWD VARCHAR2(30) NOT NULL,
	USER_NAME VARCHAR2(15),
	GENDER CHAR(1) CHECK(GENDER IN('F','M')),
	USER_PHONE VARCHAR2(30)
);

INSERT INTO MEMBER VALUES(1,'ID01','PWD01','JAMES','M','231-152-1234');
INSERT INTO MEMBER VALUES(2,'ID02','PWD02','TED','M','213-152-7854');
INSERT INTO MEMBER VALUES(3,'ID03','PWD03','LAMIAE','F','756-563-1555');
INSERT INTO MEMBER VALUES(4,'ID04','PWD04','KATY','F','237-178-4237');
INSERT INTO MEMBER VALUES(5,'ID05','PWD05','DUA','F','333-453-1273');

SELECT * FROM MEMBER;


-- FOREIGN KEY
-- 외래키, 외부키, 참조키
-- 다른 테입블의 컬럼값을 참조(REFERENCE)하여
-- 참조하는 테입블 값에 접근
-- FOREIGN KEY 제약조건을 통해 테입블들간에 관계(RELATIONSHIP) 형성된다.

-- 컬럼레벨
-- 컬럼명 자료형(길이) [CONSTRAINT 제약조건명] REFERENCES 참조할 테이블명[(참조할 컬럼명)] [삭제옵션]
-- 테이블레벨
-- [CONSTRAINT 제약조건명] FOREIGN KEY (적용할 컬럼명) REFERENCE 참조할 테이블명[(참조할 컬럼명)] [삭제옵션]
-- 참조할 컬럼명을 생략하명 참조할 테이블의 기본키(PK)를 참조할 컬럼으로 가져온다.
-- 참조하고자 하는 컬럼은 반드시 PK이거나 UNIQUE 제약조건이 걸려 있어야한다.


CREATE TABLE USER_GRADE(
	CODE NUMBER PRIMARY KEY,
	NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE VALUES(1, '일반회원');
INSERT INTO USER_GRADE VALUES(2, 'VIP');
INSERT INTO USER_GRADE VALUES(3, 'VVIP');
INSERT INTO USER_GRADE VALUES(4, 'VVVIP');

SELECT * FROM USER_GRADE;


CREATE TABLE USER_FOREIGN_KEY(
	USER_NO NUMBER PRIMARY KEY,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(30),
	USER_NAME VARCHAR2(15),
	GRADE_CODE NUMBER,
	CONSTRAINT FK_GRADE_CODE FOREIGN KEY(GRADE_CODE) REFERENCES USER_GRADE(CODE)
);
SELECT * FROM USER_FOREIGN_KEY;

INSERT INTO USER_FOREIGN_KEY VALUES(1, '123', '321','홍길동',2);
INSERT INTO USER_FOREIGN_KEY VALUES(2, 'abc', 'abc1','김길동',4);
INSERT INTO USER_FOREIGN_KEY VALUES(3, '456', '654','박길동',1);
INSERT INTO USER_FOREIGN_KEY VALUES(4, 'def', 'pass1','최길동',3);
INSERT INTO USER_FOREIGN_KEY VALUES(5, 'qwer', 'rewq','정길동',1);

SELECT *
FROM USER_FOREIGN_KEY
LEFT JOIN USER_GRADE ON(GRADE_CODE=CODE);

-- SQL Error [2291] [23000]: ORA-02291: 무결성 제약조건(MULTI.FK_GRADE_CODE)이 위배되었습니다- 부모 키가 없습니다
INSERT INTO USER_FOREIGN_KEY VALUES(6,'QQQ','WWWW','조길동',10);


-- 삭제옵션 

-- SQL Error [2292] [23000]: ORA-02292: 무결성 제약조건(MULTI.FK_GRADE_CODE)이 위배되었습니다- 자식 레코드가 발견되었습니다
DELETE FROM USER_GRADE
WHERE CODE=4;

-- 참조하고 있는 원본 테이블의(부모) 컬럼 값이 삭제 될때
-- 참조한 값을 어떻게 처리 할것인지 설정하는 옵션

-- 일반적으로 참조하는 원본 컬럼의 내용을 삭제한려 한다면
-- 외래키로 사용 중인 자식 컬럼이 존재할때는 함부러 삭제 불가능하다. SQL Error [2292] [23000]: ORA-02292
-- 함부로 삭제할 수 없다. 이를 변경하기 위한 옵션

-- 1. 부모 컬럼을 삭제 할때 자식을 NULL로 변경하기
-- ON DELETE SET NULL
-- 2. 부모 컬럼을 삭제할 때 관련된 자식도 함께 삭제
-- ON DELETE CASCASE


SELECT * FROM USER_GRADE;
SELECT * FROM USER_FOREIGN_KEY;

-- SQL Error [2449] [72000]: ORA-02449: 외래 키에 의해 참조되는 고유/기본 키가 테이블에 있습니다
DROP TABLE USER_GRADE;
DROP TABLE USER_FOREIGN_KEY; -- 이거(자식) 먼저 지우기


CREATE TABLE USER_FOREIGN_KEY(
	USER_NO NUMBER PRIMARY KEY,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(30),
	USER_NAME VARCHAR2(15),
	GRADE_CODE NUMBER,
	CONSTRAINT FK_GRADE_CODE FOREIGN KEY(GRADE_CODE) 
	REFERENCES USER_GRADE(CODE) ON DELETE CASCADE
);

INSERT INTO USER_FOREIGN_KEY VALUES(1, '123', '321','홍길동',2);
-- INSERT INTO USER_FOREIGN_KEY VALUES(2, 'abc', 'abc1','김길동',4);
INSERT INTO USER_FOREIGN_KEY VALUES(3, '456', '654','박길동',1);
INSERT INTO USER_FOREIGN_KEY VALUES(4, 'def', 'pass1','최길동',3);
INSERT INTO USER_FOREIGN_KEY VALUES(5, 'qwer', 'rewq','정길동',1);

SELECT * FROM USER_FOREIGN_KEY;

DELETE FROM USER_GRADE
WHERE CODE=1;

SELECT * FROM USER_GRADE;
SELECT * FROM USER_FOREIGN_KEY;


-- 2. ON DELETE CASCADE
-- 자식 테입블의 데이터도 삭제
DROP TABLE USER_FOREIGN_KEY;


-- SUBQUERY를 활용하여 테이블 만들기
-- 컬럼명, 테이터타입, 값, NOT NULL 복사가능

CREATE TABLE EMP_COPY
AS SELECT * FROM EMPLOYEE;

SELECT * FROM EMP_COPY;

DROP TABLE EMP_COPY;

CREATE TABLE EMP_COPY
AS SELECT EMP_ID, EMP_NAME FROM EMPLOYEE WHERE JOB_CODE='J2';

SELECT * FROM EMP_COPY;


-- 테이블의 형식만 복사하기
-- 값을 제외한 형식 복사하기
CREATE TABLE EMP_COPY2
AS SELECT * FROM EMPLOYEE WHERE 1 = 0;

SELECT * FROM EMP_COPY2;

-- 서브쿼리를 이용한 특정 컬럼 복사
CREATE TABLE EMP_COPY3
AS SELECT EMP_ID, EMP_NAME, SALARY, DEPT_CODE "DEPT", JOB_CODE "JOB"
FROM EMPLOYEE;

SELECT * FROM EMP_COPY3;
SELECT DEPT, JOB FROM EMP_COPY3;

-- 각 컬럼에 값을 기록하지 않을 경우 기본값 설정하기
CREATE TABLE DEFAULT_TABLE(
	DATA_COL1 VARCHAR2(30) DEFAULT '없음',
	DATA_COL2 DATE DEFAULT CURRENT_DATE
);

-- NULL 값이 저장
INSERT INTO DEFAULT_TABLE VALUES(NULL, NULL);
-- 기본값으로 저장
INSERT INTO DEFAULT_TABLE VALUES(DEFAULT, DEFAULT);

SELECT * FROM DEFAULT_TABLE;

-- ALTER 사용하여 제약조건을 테이블 생성 후 추가
-- DDL

-- ALTER TABLE 테이블명 ADD PRIMARY KEY(컬럼명)
-- ALTER TABLE 테이블명 ADD FOREIGN KEY(컬럼명) REFERENCES 참조할 테이블명 (컬럼명)
-- ALTER TABLE 테이블명 ADD UNIQUE(컬럼명)
-- ALTER TABLE 테이블명 ADD CHECK(조건식)
-- ALTER TABLE 테이블명 MODIFY 컬럼명 NOT NULL

ALTER TABLE EMPLOYEE ADD FOREIGN KEY(DEPT_CODE) REFERENCES DEPARTMENT;

-- 제약조건을 중간에 변경 할 경우 이미 저장한 값등을 파악하여 제약조건에 위배되지 않는지 확인 해야 한다.
-- ALTER TABLE EMPLOYEE ADD FOREIGN KEY(MANAGER_ID) REFERENCES EMPLOYEE;

ALTER TABLE EMPLOYEE ADD FOREIGN KEY(JOB_CODE) REFERENCES JOB;
ALTER TABLE EMPLOYEE ADD FOREIGN KEY(SAL_LEVEL) REFERENCES SAL_GRADE;

ALTER TABLE EMPLOYEE ADD CHECK(ENT_YN IN ('Y','N'));
ALTER TABLE EMPLOYEE ADD CHECK(SALARY > 0);
ALTER TABLE EMPLOYEE ADD UNIQUE(EMP_NO);

ALTER TABLE DEPARTMENT ADD FOREIGN KEY(LOCATION_ID) REFERENCES LOCATION;
ALTER TABLE LOCATION ADD FOREIGN KEY(NATIONAL_CODE) REFERENCES NATIONAL;


SELECT * 
FROM USER_CONSTRAINTS C1
JOIN USER_CONS_COLUMNS C2 ON(C1.TABLE_NAME = C2.TABLE_NAME AND C1.CONSTRAINT_NAME = C2.CONSTRAINT_NAME)
WHERE C1.TABLE_NAME IN('EMPLOYEE','DEPARTMENT','LOCATION');
















