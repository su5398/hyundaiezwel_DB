-- CREATE : 데이터 베이스의 객체를 생성하는 DDL

-- 제약조건
-- UNIQUE : 중복 허용X
-- NOT NULL : NULL 받을 수 없다.
-- CHECK : 특정 범위 값만 허용
-- PRIMARY KEY : UNIQUE + NOT NULL
--					한 개의 테이블에 하나만 존재.
-- FOREIGN KEY : 다른 테이블의 값을 참조.
--					기본키, 유니크 제약조건이 걸려있는 컬럼만 참조 가능.



-- DML(데이터 조작언어) --
-- INSERT, UPDATE, DELETE, SELECT(DQL) --
-- [CURD] --
-- C(CREATE) : INSERT / 데이터 추가
-- R(READ)   : SELECT / 데이터 조회
-- U(UPDATE) : UPDATE / 데이터 수정
-- D(DELETE) : DELETE / 데이터 삭제


-- INSERT : 새로운 행을 특정 테이블에 추가하는 명령어
-- 			실행 후에는 테입블의 ROW(행)가 증가 한다.

-- INSERT INTO 테이블명[(컬럼명, 컬럼명, ...)] VALUES(값, 값,...);

-- 컬럼을 명시하여 데이터 추가
INSERT INTO EMPLOYEE(EMP_ID, EMP_NAME, EMP_NO, EMAIL, PHONE, DEPT_CODE, JOB_CODE, SAL_LEVEL, 
					 SALARY, BONUS, MANAGER_ID, HIRE_DATE, ENT_DATE, ENT_YN)
VALUES(500,'권장현','970311-1234567','su539@naver.com','01012345678','D1','J7','S4',3100000,0.1,'200',
		CURRENT_DATE, NULL, DEFAULT);

SELECT * FROM EMPLOYEE
WHERE EMP_ID = 500;

-- 컬럼을 명시하지 않고 데이터 추가(모든 컬럼에 값을 추가)
INSERT INTO EMPLOYEE
VALUES(900,'권장형','660101-2345678','ASDF@or.kr','01033335555','D1','J7','S3','4300000',0.2,'200', CURRENT_DATE, NULL, DEFAULT);

SELECT * FROM EMPLOYEE
WHERE EMP_ID IN(500,900);

-- INSERT + SUBQUERY
-- VALUES 대신 SUBQUERY로 값을 지정하여 추가
CREATE TABLE EMP_01 (
	EMP_ID NUMBER,
	EMP_NAME VARCHAR2(20),
	DEPT_TITLE VARCHAR2(40)
);


SELECT * FROM EMP_01;

INSERT INTO EMP_01(
	SELECT EMP_ID, EMP_NAME, DEPT_TITLE
	FROM EMPLOYEE
	LEFT JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID)
);


-- UPDATE : 해당 테이블의 데이터를 수정하는 명령어
-- UPDATE 테이블명 SET 컬럼명 = 수정할 값, 컬럼명=수정할 값,...
-- [WHERE 조건]

-- UPDATE 실행 후 데이터의 수는(ROW의 개수) 변하지 않는다.

CREATE TABLE DEPT_COPY
AS SELECT * FROM DEPARTMENT;

SELECT * FROM DEPT_COPY;

-- D9 부서를 총무부 -> 전략기획부
UPDATE DEPT_COPY
SET DEPT_TITLE='전략기획부'
WHERE DEPT_ID='D9';


-- employee 테이블에서 주민번호 잘못 표기되어 있는 사원이 있다.
CREATE TABLE TEST_EMP
AS SELECT * FROM EMPLOYEE;

-- EMPLOYEE 테이블에서 주민번호가 잘못 표기 되어있는 사원이 있다.
-- '661230','631126','850705'로 변경하는 UPDATE구문 3개 작성

-- 1. 잘못 표기된 사원 조회
-- 사번 : 200, 201, 214
SELECT * FROM TEST_EMP;
-- 2. UPDATE
--
UPDATE TEST_EMP
SET EMP_NO='631126'||SUBSTR(EMP_NO,7)
WHERE EMP_ID='200';

UPDATE TEST_EMP
SET EMP_NO='661230'||SUBSTR(EMP_NO,7)
WHERE EMP_ID='201';

UPDATE TEST_EMP
SET EMP_NO='850705'||SUBSTR(EMP_NO,7)
WHERE EMP_ID='214';

SELECT EMP_ID, EMP_NO
FROM EMPLOYEE
WHERE EMP_ID IN(200,201,214)

-- UPDATE + SUBQUERY
-- UPDATE 테이블명 SET 컬럼명=(서브 쿼리)

CREATE TABLE EMP_SALARY
AS
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY, BONUS
FROM EMPLOYEE;

-- 유재식 사원과 같은 급여와 보너스를 받게끔
-- 방명수 사원의 급여보너스를 수정

-- 단일행 서브쿼리 활용
UPDATE EMP_SALARY
SET SALARY = (SELECT SALARY FROM EMP_SALARY WHERE EMP_NAME='유재식'),
	BONUS = (SELECT BONUS FROM EMP_SALARY WHERE EMP_NAME='유재식')
WHERE EMP_NAME='방명수';

SELECT * FROM EMP_SALARY;

-- 정중하, 전형돈 사원의 급여, 보너스도 유재식과 동일하게

-- 다중열 서브쿼리 
UPDATE EMP_SALARY
SET (SALARY, BONUS) = (SELECT SALARY, BONUS FROM EMP_SALARY WHERE EMP_NAME ='유재식')
WHERE EMP_NAME IN ('정중하','전형돈');

SELECT * FROM EMP_SALARY
WHERE EMP_NAME IN ('유재식','방명수','정중하','전형돈');

-- 아시아 지역에서 근무하는 지원들의 보너스를 0.25로 수정

-- 서브쿼리
SELECT EMP_ID
FROM EMP_SALARY
JOIN DEPARTMENT ON (DEPT_CODE=DEPT_ID)
JOIN LOCATION ON (LOCATION_ID=LOCAL_CODE)
WHERE LOCAL_NAME LIKE 'ASIA%';

--
UPDATE EMP_SALARY SET BONUS=0.25
WHERE EMP_ID IN (
				SELECT EMP_ID
				FROM EMP_SALARY
				JOIN DEPARTMENT ON (DEPT_CODE=DEPT_ID)
				JOIN LOCATION ON (LOCATION_ID=LOCAL_CODE)
				WHERE LOCAL_NAME LIKE 'ASIA%'
);

SELECT * FROM EMP_SALARY;

-- SQL Error [2291] [23000]: ORA-02291: 무결성 제약조건(MULTI.SYS_C0023273)이 위배되었습니다- 부모 키가 없습니다
-- 외래키제약조건 위배
UPDATE EMPLOYEE
SET DEPT_CODE ='D0'
WHERE DEPT_CODE = 'D6';



-- DELETE
-- 테이블의 행을 삭제하는 명령어
-- 수행하고 나면 테이블의 행의 개수가 줄어든다.

-- DELETE FROM 테이블명 [WHERE 조건]
-- WHERE 조건을 작성하지 않고 실행하명 모든 정보가 삭제

CREATE TABLE TEST_DELETE
AS SELECT * FROM EMPLOYEE;

-- 전체 삭제
DELETE FROM TEST_DELETE;
SELECT * FROM TEST_DELETE;

SELECT * FROM EMP_SALARY;

-- EMP_SALARY에서 BONUS를 0.25만큼 받지 않는 사원 삭제
DELETE FROM EMP_SALARY;



-- ALTER --
DROP TABLE DEPT_COPY;

CREATE TABLE DEPT_COPY
AS SELECT * FROM DEPARTMENT;

SELECT * FROM DEPT_COPY;

-- DEPT_COPY 테이블에 컬럼 추가
ALTER TABLE DEPT_COPY
ADD(LNAME VARCHAR2(20));

SELECT * FROM DEPT_COPY;

-- 컬럼 삭제
ALTER TABLE DEPT_COPY DROP COLUMN LNAME;
SELECT * FROM DEPT_COPY;

-- 테이블에 기본값을 적용하여 컬럼 추가
ALTER TABLE DEPT_COPY
ADD(LNAME VARCHAR(20) DEFAULT '한국');

SELECT * FROM DEPT_COPY;

-- 컬럼에 제약조건 추가하기
CREATE TABLE DEPT_COPY2
AS SELECT * FROM DEPT_COPY;

SELECT * FROM DEPT_COPY2;

-- DEPT_COPY2에
-- PK, UNIQUE, NOTNULL 추가해보기

ALTER TABLE DEPT_COPY2
ADD CONSTRAINT PK_DEPT_CP2 PRIMARY KEY(DEPT_ID);

ALTER TABLE DEPT_COPY2
ADD CONSTRAINT UK_DEPT_CP2 UNIQUE(DEPT_TITLE);

ALTER TABLE DEPT_COPY2
MODIFY LNAME CONSTRAINT NN_DEPT_LNAME NOT NULL;


SELECT * FROM USER_TAB_COLUMNS
WHERE TABLE_NAME = 'DEPT_COPY2';

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'DEPT_COPY2';

SELECT * FROM DEPT_COPY2;

-- SQL Error [1] [23000]: ORA-00001: 무결성 제약 조건(MULTI.PK_DEPT_CP2)에 위배됩니다
INSERT INTO DEPT_COPY2 VALUES('D9','샘플부서','L1','한국');

-- SQL Error [12899] [72000]: ORA-12899: "MULTI"."DEPT_COPY2"."DEPT_ID" 열에 대한 값이 너무 큼(실제: 3, 최대값: 2)
INSERT INTO DEPT_COPY2 VALUES('D10','샘플부서','L1','한국');

-- 컬럼 수정
ALTER TABLE DEPT_COPY2
MODIFY DEPT_ID CHAR(3)
MODIFY DEPT_TITLE VARCHAR(30)
MODIFY LOCATION_ID VARCHAR(2)
MODIFY LNAME CHAR(20);

INSERT INTO DEPT_COPY2 VALUES('D10','샘플부서','L1','한국');

SELECT * FROM DEPT_COPY2;

-- DEPT_TITLE 컬럼을 수정 VARCHAR2(10)

-- SQL Error [1441] [72000]: ORA-01441: 일부 값이 너무 커서 열 길이를 줄일 수 없음
ALTER TABLE DEPT_COPY2
MODIFY DEPT_TITLE VARCHAR2(10);

-- DEFAULT 추가
ALTER TABLE DEPT_COPY2
MODIFY LNAME VARCHAR2(20) DEFAULT '대한민국';

INSERT INTO DEPT_COPY2 VALUES('D11','개발팀','L1',DEFAULT);
SELECT * FROM DEPT_COPY2;

-- 컬럼의 이름 변경
ALTER TABLE DEPT_COPY2
RENAME COLUMN DEPT_TITLE TO DEPT_NAME;

SELECT * FROM DEPT_COPY2;

-- 테이블 이름 변경
ALTER TABLE DEPT_COPY2
RENAME TO DEPT_COPY_TWO;

SELECT * FROM DEPT_COPY_TWO;
SELECT * FROM DEPT_COPY2;


-- 테이블 한정으로 RENAME 간략하게 작성 가능
RENAME DEPT_COPY_TWO TO DEPT_COPY2;




-- TCL
-- CONTROL
-- 제어 언어
-- COMMIT, ROLLBACK ...

-- 트랜잭션 : 데이터 처리하는 최소의 작업 단위
-- 모두 성공 OR 모두 실패
-- COMMIT(저장/반영), ROLLBACK(취소)

-- COMMIT : 트랜잭션이 종료될때  정상적으로 종료되었다면 변경한 사항을 영구히 DB에 저장
-- ROLLBACK : 트랜잭션 작업 중 오류가 발생할 경우 작업한 내역을 취소(복구).
--				가장 최근에 COMMIT했던 시점으로 ROLLBACK;


COMMIT;

CREATE TABLE USER_TBL(
	NO NUMBER UNIQUE,
	ID VARCHAR2(20) NOT NULL UNIQUE,
	PW VARCHAR2(20) NOT NULL
);

SELECT * FROM USER_TBL;

ROLLBACK;
-- 테이블 생성 후 ROLLBACK을 하더라도 생성된 테이블이 사라지지는 않는다.


INSERT INTO USER_TBL VALUES(1, 'TEST01','PASS01');
INSERT INTO USER_TBL VALUES(2, 'TEST02','PASS02');

SELECT * FROM USER_TBL;
COMMIT; -- 여기까지 작업한 DML 내역을 DB에 반영

INSERT INTO USER_TBL VALUES(3, 'TEST03', 'PASS03');
SELECT * FROM USER_TBL;

ROLLBACK; -- 가장 최근에 COMMIT한 시점으로 되돌아 가겠다.

SELECT * FROM USER_TBL;

INSERT INTO USER_TBL VALUES(3, 'TEST03', 'PASS03');
INSERT INTO USER_TBL VALUES(4, 'TEST04', 'PASS03');
INSERT INTO USER_TBL VALUES(5, 'TEST05', 'PASS03');
INSERT INTO USER_TBL VALUES(6, 'TEST06', 'PASS03');

-- -------------------
-- DML 명령어는 트랜잭션의 개념이 아니다.
-- COMMIT/ROLLBACK 불가능
-- 또한 이전 DML(INSERT, UPDATE, ..)을 실행 후
-- DDL 명령어 사용하면 이전까지의 데이터 조작 내용이 자동 COMMIT 처리 된다.

COMMIT;


-- DROP --
-- 객체 자체를 제거할 때 사용하는 명령어

-- DROP 객체 객체명
 SELECT * FROM DEPT_COPY2;

-- 컬럼 삭제
ALTER TABLE DEPT_COPY
DROP (LNAME);

ALTER TABLE DEPT_COPY
DROP(DEPT_TITLE, LOCATION_ID);


-- SQL Error [12983] [72000]: ORA-12983: 테이블에 모든 열들을 삭제할 수 없습니다
ALTER TABLE DEPT_COPY
DROP (DEPT_ID);

-- 제약조건 삭제
CREATE TABLE CONST_TAB(
	EID CHAR(2),
	ENAME VARCHAR2(15) NOT NULL,
	AGE NUMBER NOT NULL,
	DEPT CHAR(5),
	CONSTRAINT PK_TAB PRIMARY KEY(EID),
	CONSTRAINT UK_TAB UNIQUE(ENAME),
	CONSTRAINT CK_TAB CHECK(AGE>0),
	CONSTRAINT FK_TAB FOREIGN KEY(DEPT) REFERENCES DEPARTMENT ON DELETE CASCADE
);

SELECT * FROM CONST_TAB;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'CONST_TAB';

ALTER TABLE CONST_TAB
DROP CONSTRAINT CK_TAB;

-- 제약조건 여러개를 한번에 삭제도
ALTER TABLE CONST_TAB
DROP CONSTRAINT FK_TAB
DROP CONSTRAINT PK_TAB
DROP CONSTRAINT UK_TAB;

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME 'CONST_TAB';

-- NOT NULL 삭제하기
ALTER TABLE CONST_TAB
DROP CONSTRAINT SYS_C0023316;

ALTER TABLE CONST_TAB
MODIFY (AGE NULL);

SELECT * FROM CONST_TAB;

-- 객체삭제
DROP TABLE CONST_TAB;
DROP TABLE DEPT_COPY2;

-- 계정과 같은 객체도 삭제 가능
DROP USER MULTI12;

-- 오라클 객체 --
-- VIEW(뷰)

/*
 * 관리자 계정에서 권한 주기
 * GRANT CREATE VIEW TO MULTI;
 * 
 */

-- VIEW : SELECT를 실행한 결과 화면을 담는 객체.
--			VIEW에는 SELECT 문장 자체를 정장. 호출할때마다 해당 쿼리를 실행해서 결과를 보여준다.

-- 실질적으로 데이터를 담고 있지 않다.
-- 사용자에게 노출하고 싶지 않은 정보나 업무에  필요한 정보만 조회하고자 할때 사용.

-- CREATE [OR REPLACE] VIEW 뷰이름
-- AS 서브쿼리(뷰에서 확인할 SELECT)

CREATE OR REPLACE VIEW V_EMP
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE FROM EMPLOYEE;

SELECT * FROM V_EMP;

-- 뷰는 SELECT문을 저장하는 가상의 테이블.
-- 이미 생성된 뷰가 있더라도 새롭게 생성 가능(바뀐다.)


CREATE OR REPLACE VIEW V_EMP(사번, 이름, 부서, 직급)
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, JOB_CODE FROM EMPLOYEE;

SELECT * FROM V_EMP;

SELECT * FROM USER_VIEWS;

-- 사번, 이름, 직급명, 부서명, 근무지역명을 조회하고
-- 그 결과를 V_RES_EMP라는 뷰를 만들어 뷰를 통해 결과를 조회

-- 1) 서브쿼리 준비
SELECT EMP_ID, EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE 
LEFT JOIN JOB USING(JOB_CODE)
LEFT JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID)
LEFT JOIN LOCATION ON(LOCATION_ID=LOCAL_CODE);

-- 2) 뷰 생성
CREATE OR REPLACE VIEW V_RES_EMP(사번, 이름, 직급명, 부서명, 근무지역명)
AS SELECT EMP_ID, EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE 
LEFT JOIN JOB USING(JOB_CODE)
LEFT JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID)
LEFT JOIN LOCATION ON(LOCATION_ID=LOCAL_CODE);

-- 확인
SELECT * FROM V_RES_EMP;

SELECT * FROM USER_VIEWS;


SELECT * FROM V_RES_EMP WHERE 사번 = '213';
SELECT 사번, 이름, 직급명 FROM V_RES_EMP;


-- VIEW는 SELECT 저장하고 있기 때문에
-- 원본 테이블이 변경되면 뷰를 통해 확인하는 내용도 변경된다.

UPDATE EMPLOYEE SET EMP_NAME ='정중아'
WHERE EMP_ID='205';

SELECT * FROM EMPLOYEE WHERE EMP_ID=205;
SELECT * FROM V_RES_EMP WHERE 사번=205;


-- 뷰 삭제
DROP VIEW V_RES_EMP;

SELECT * FROM USER_VIEWS;

-- 뷰에는 연산을 포함하는 SELECT도 저장 가능
SELECT EMP_ID, EMP_NAME,
		DECODE(SUBSTR(EMP_NO,8,1),1,'남성','여성')
FROM EMPLOYEE;


-- 뷰생성
CREATE OR REPLACE VIEW V_EMP(사번, 사원명, 성별)
AS
SELECT EMP_ID, EMP_NAME,
		DECODE(SUBSTR(EMP_NO,8,1),1,'남성','여성')
FROM EMPLOYEE;

SELECT * FROM V_EMP;
SELECT 성별, 사원명 FROM V_EMP;









